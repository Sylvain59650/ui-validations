(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.uiValidations = mod.exports;
  }
})(this, function (exports) {
  "use strict";

  function getId(input) {
    if (input.id) {
      return input.id;
    };
    input.id = input.name;
    return input.name;
  }

  function addMsg(input, msg, cssClass) {
    var label = newElement("label", { id: getId(input) + "_msg", for: getId(input), class: "field-validation " + cssClass }, msg);
    input.afterEnd(label);
    Positionizer.setRelativePosition(input, label, "bottom-left");
    input.addClass(cssClass);
  }

  function removeMsg(input) {
    var id = getId(input) + "_msg";
    var label = qsi(id);
    if (label !== null) {
      label.remove(label);
    }
    input.class("-info -warning -error");
  }

  function cleanErrors() {
    qsa(".field-validation").remove();
    qsa(".error").class("-info -warning -error");
  }

  function addError(input, msg) {
    addMsg(input, msg, "error");
  }

  function addWarning(input, msg) {
    addMsg(input, msg, "warning");
  }

  function addInfo(input, msg) {
    addMsg(input, msg, "info");
  }

  var dico = {
    required: function required() {
      var _validators;

      return !(_validators = validators).isEmpty.apply(_validators, arguments);
    }
  };

  function validate(constraints) {
    var err = 0;
    cleanErrors();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = constraints[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var constraint = _step.value;

        var field = qsi(constraint.field);
        if (field === null) {
          field = qsn(constraint.field);
        }
        if (field !== null) {
          var value = field.val();
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = constraint.rules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var rule = _step2.value;

              if (rule.type === "custom") {
                if (!rule.fn(value)) {
                  addError(field, rule.msg);
                  err++;
                  break;
                }
              } else if (dico[rule.type]) {
                var fn = dico[rule.type];
                if (!fn(value)) {
                  addError(field, rule.msg);
                  err++;
                  break;
                }
              } else {
                console.error("rule " + rule.type + " undefined");
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        } else {
          console.error("field " + constraint.field + " not found");
        }
        return err === 0;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
  exports.addMsg = addMsg;
  exports.addInfo = addInfo;
  exports.addWarning = addWarning;
  exports.addError = addError;
  exports.removeMsg = removeMsg;
  exports.validate = validate;
  exports.cleanErrors = cleanErrors;
});